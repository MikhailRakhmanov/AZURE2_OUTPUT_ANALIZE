//#include "stdafx.h"
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
#include "math.h"

#include "my_services.h"
#include "Constants.h"

using namespace std;

const char
NucName[][5] = { "n", "H", "He", "Li", "Be", "B", "C", "N", "O", "F", "Ne", "Na", "Mg", "Al", "Si", "P", "S", "Cl",
"Ar", "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se",
"Br", "Kr", "Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb",
"Te", "I", "Xe", "Cs", "Ba", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er",
"Tm", "Yb", "Lu", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At",
"Rn", "Fr", "Ra", "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No",
"Lr", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "110", "111", "112", "113", "114", "115", "116", "117", "118",
"119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130" };
char nuc[4];
//------------------------------------------------------------------------------
// precalculated factorials from 0! upto 167!
long double LONG_FACTORIAL[168] =
{ 1.000000000000000e+00L, 1.000000000000000e+00L, 2.000000000000000e+00L, 6.000000000000000e+00L,
2.400000000000000e+01L, 1.200000000000000e+02L, 7.200000000000000e+02L, 5.040000000000000e+03L,
4.032000000000000e+04L, 3.628800000000000e+05L, 3.628800000000000e+06L, 3.991680000000000e+07L,
4.790016000000000e+08L, 6.227020800000000e+09L, 8.717829120000000e+10L, 1.307674368000000e+12L,
2.092278988800000e+13L, 3.556874280960000e+14L, 6.402373705728000e+15L, 1.216451004088320e+17L,
2.432902008176640e+18L, 5.109094217170944e+19L, 1.124000727777608e+21L, 2.585201673888498e+22L,
6.204484017332394e+23L, 1.551121004333099e+25L, 4.032914611266056e+26L, 1.088886945041835e+28L,
3.048883446117139e+29L, 8.841761993739702e+30L, 2.652528598121911e+32L, 8.222838654177923e+33L,
2.631308369336935e+35L, 8.683317618811886e+36L, 2.952327990396041e+38L, 1.033314796638614e+40L,
3.719933267899012e+41L, 1.376375309122635e+43L, 5.230226174666011e+44L, 2.039788208119744e+46L,
8.159152832478977e+47L, 3.345252661316381e+49L, 1.405006117752880e+51L, 6.041526306337384e+52L,
2.658271574788449e+54L, 1.196222208654802e+56L, 5.502622159812089e+57L, 2.586232415111682e+59L,
1.241391559253607e+61L, 6.082818640342676e+62L, 3.041409320171338e+64L, 1.551118753287382e+66L,
8.065817517094388e+67L, 4.274883284060026e+69L, 2.308436973392414e+71L, 1.269640335365828e+73L,
7.109985878048635e+74L, 4.052691950487722e+76L, 2.350561331282879e+78L, 1.386831185456898e+80L,
8.320987112741390e+81L, 5.075802138772248e+83L, 3.146997326038794e+85L, 1.982608315404440e+87L,
1.268869321858842e+89L, 8.247650592082471e+90L, 5.443449390774431e+92L, 3.647111091818869e+94L,
2.480035542436831e+96L, 1.711224524281413e+98L, 1.197857166996989e+100L, 8.504785885678623e+101L,
6.123445837688609e+103L, 4.470115461512684e+105L, 3.307885441519386e+107L, 2.480914081139540e+109L,
1.885494701666050e+111L, 1.451830920282859e+113L, 1.132428117820630e+115L, 8.946182130782975e+116L,
7.156945704626380e+118L, 5.797126020747368e+120L, 4.753643337012842e+122L, 3.945523969720659e+124L,
3.314240134565353e+126L, 2.817104114380550e+128L, 2.422709538367273e+130L, 2.107757298379528e+132L,
1.854826422573984e+134L, 1.650795516090846e+136L, 1.485715964481761e+138L, 1.352001527678403e+140L,
1.243841405464131e+142L, 1.156772507081642e+144L, 1.087366156656743e+146L, 1.032997848823906e+148L,
9.916779348709497e+149L, 9.619275968248212e+151L, 9.426890448883248e+153L, 9.332621544394415e+155L,
9.332621544394415e+157L, 9.425947759838359e+159L, 9.614466715035127e+161L, 9.902900716486180e+163L,
1.029901674514563e+166L, 1.081396758240291e+168L, 1.146280563734708e+170L, 1.226520203196138e+172L,
1.324641819451829e+174L, 1.443859583202494e+176L, 1.588245541522743e+178L, 1.762952551090245e+180L,
1.974506857221074e+182L, 2.231192748659814e+184L, 2.543559733472188e+186L, 2.925093693493016e+188L,
3.393108684451898e+190L, 3.969937160808721e+192L, 4.684525849754291e+194L, 5.574585761207606e+196L,
6.689502913449127e+198L, 8.094298525273444e+200L, 9.875044200833601e+202L, 1.214630436702533e+205L,
1.506141741511141e+207L, 1.882677176888926e+209L, 2.372173242880047e+211L, 3.012660018457660e+213L,
3.856204823625804e+215L, 4.974504222477287e+217L, 6.466855489220474e+219L, 8.471580690878821e+221L,
1.118248651196004e+224L, 1.487270706090686e+226L, 1.992942746161519e+228L, 2.690472707318050e+230L,
3.659042881952549e+232L, 5.012888748274992e+234L, 6.917786472619488e+236L, 9.615723196941089e+238L,
1.346201247571752e+241L, 1.898143759076171e+243L, 2.695364137888163e+245L, 3.854370717180073e+247L,
5.550293832739305e+249L, 8.047926057471992e+251L, 1.174997204390911e+254L, 1.727245890454639e+256L,
2.556323917872866e+258L, 3.808922637630570e+260L, 5.713383956445855e+262L, 8.627209774233240e+264L,
1.311335885683453e+267L, 2.006343905095682e+269L, 3.089769613847351e+271L, 4.789142901463394e+273L,
7.471062926282894e+275L, 1.172956879426414e+278L, 1.853271869493735e+280L, 2.946702272495038e+282L,
4.714723635992061e+284L, 7.590705053947219e+286L, 1.229694218739449e+289L, 2.004401576545303e+291L,
3.287218585534296e+293L, 5.423910666131589e+295L, 9.003691705778437e+297L, 1.503616514864999e+300L};
//------------------------------------------------------------------------------
// precalculated factorials from 1! upto 100!
double FACTORIAL[101] =
{ 1.0000000000e+00, 1.0000000000e+00, 2.0000000000e+00,
6.0000000000e+00, 2.4000000000e+01, 1.2000000000e+02,
7.2000000000e+02, 5.0400000000e+03, 4.0320000000e+04,
3.6288000000e+05, 3.6288000000e+06, 3.9916800000e+07,
4.7900160000e+08, 6.2270208000e+09, 8.7178291200e+10,
1.3076743680e+12, 2.0922789888e+13, 3.5568742810e+14,
6.4023737057e+15, 1.2164510041e+17, 2.4329020082e+18,
5.1090942172e+19, 1.1240007278e+21, 2.5852016739e+22,
6.2044840173e+23, 1.5511210043e+25, 4.0329146113e+26,
1.0888869450e+28, 3.0488834461e+29, 8.8417619937e+30,
2.6525285981e+32, 8.2228386542e+33, 2.6313083693e+35,
8.6833176188e+36, 2.9523279904e+38, 1.0333147966e+40,
3.7199332679e+41, 1.3763753091e+43, 5.2302261747e+44,
2.0397882081e+46, 8.1591528325e+47, 3.3452526613e+49,
1.4050061178e+51, 6.0415263063e+52, 2.6582715748e+54,
1.1962222087e+56, 5.5026221598e+57, 2.5862324151e+59,
1.2413915593e+61, 6.0828186403e+62, 3.0414093202e+64,
1.5511187533e+66, 8.0658175171e+67, 4.2748832841e+69,
2.3084369734e+71, 1.2696403354e+73, 7.1099858780e+74,
4.0526919505e+76, 2.3505613313e+78, 1.3868311855e+80,
8.3209871127e+81, 5.0758021388e+83, 3.1469973260e+85,
1.9826083154e+87, 1.2688693219e+89, 8.2476505921e+90,
5.4434493908e+92, 3.6471110918e+94, 2.4800355424e+96,
1.7112245243e+98, 1.1978571670e100, 8.5047858857e101,
6.1234458377e103, 4.4701154614e105, 3.3078854415e107,
2.4809140811e109, 1.8854947017e111, 1.4518309203e113,
1.1324281178e115, 8.9461821308e116, 7.1569457046e118,
5.7971260207e120, 4.7536433370e122, 3.9455239697e124,
3.3142401346e126, 2.8171041144e128, 2.4227095384e130,
2.1077572984e132, 1.8548264226e134, 1.6507955161e136,
1.4857159645e138, 1.3520015277e140, 1.2438414055e142,
1.1567725071e144, 1.0873661567e146, 1.0329978488e148,
9.9167793487e149, 9.6192759682e151, 9.4268904489e153,
9.3326215444e155, 9.3326215444e157 };
//------------------------------------------------------------------------------
void doTrim(char *source, char * dest, char c)
{
	int is = 0, id = 0;
	while (source[is] != '\0')
	{
		if (source[is] != c) dest[id++] = source[is++];		
	}
	dest[id] = '\0';
}
//----------------------------------------------------------------------
const char* getElementName(int z)
{
	if (z<0) return "??";
	if (z>130) { sprintf_s(nuc, 4, "%4d", z); return &nuc[0]; }
	return &NucName[z][0];
}
//----------------------------------------------------------------------
// integer POWER of x
double Npow(double x, int N)
{
	double res = 1.0, y;
	int i;
	if (N == 0) return 1.0; if (x == 0.0) return 0.0;
	if (N>0) y = x; else y = 1.0 / x;
	N = abs(N);
	for (i = 1; i <= N; i++) res = res*y;
	return(res);
}
//------------------------------------------------------------------------------
double getPhiAngle(double x, double y)// ugol phi v intervale [0;2Pi]
{
	if (fabs(x) + fabs(y) < 1.e-10) return 0.0;

	double ang = acos(fabs(x) / sqrt(x*x + y*y));//I
	if (x<0.)
		if (y<0.)//III
			ang += Constants::M_PI;
		else //II
			ang = Constants::M_PI - ang;
	else if (y<0.)//IV
		ang = 2 * Constants::M_PI - ang;
	return ang;
}
//---------------------------------------------------------------------------------------------
double fsign(double x, double y)// =sign(y)*X
{ 
	if (y<0.0) return(-x); 
	else return(x); 
}
//---------------------------------------------------------------------------------------------
int isign(int x, int y)// =sign(y)*X
{ 
	if (y<0) return(-x); 
	else return(x); 
}
//---------------------------------------------------------------------------------------------
bool chet(int n) { if (n % 2) return false; else return true; }
//---------------------------------------------------------------------------------------------
double PHASEF(int N)
{ 
	return 1.0*(1 - 2 * abs(N - 2 * (N / 2))); 
}
//------------------------------------------------------------------------------
double factorial(int n)
{
	if (n >= 0 && n <= 165) return (double)(LONG_FACTORIAL[n]);
	else if (n>165)
	{
		long double r = LONG_FACTORIAL[100];
		for (int i = 101; i <= n; i++) r = r*i;
		return (double)r;
	}
	else return 0;
}
double dFact(int n)// (n)!!
{
	if (n <= 0 || n>100) return 0;
	double r = 1;
	if (n % 2 == 0) for (int i = 2; i <= n; i += 2) r = r*i;// chet
	else for (int i = 1; i <= n; i += 2) r = r*i;// ne chet
	return r;
}
//------------------------------------------------------------------------------
long double long_factorial(int n)
{
	if (n >= 0 && n <= 167) return LONG_FACTORIAL[n];
	else if (n>167)
	{
		long double r = LONG_FACTORIAL[167];
		for (int i = 168; i <= n; i++) r = r*i;
		return r;
	}
	else return 0;
}
//------------------------------------------------------------------------------
//     vozvrashaet index i v massive takoi chto array[i]<x<array[i+1]
//                    shag v array[] ne ravnomernyi
int getIndex(double x, double array[], int N)
{
	if (x < array[0])   return -1;
	if (x > array[N - 1]) return -2;
	int i, i1 = 0, i2 = N - 1;
	while (i2 - i1 > 1)
	{
		i = (i1 + i2) / 2;
		if (x > array[i] || fabs(x - array[i])<Constants::zerro) i1 = i;
		else i2 = i;
	}
	return i1;
}
//------------------------------------------------------------------------------
double InterpolationWeights[3] = { 1. / 24.,-1. / 6.,0.25 };
double Interpolation(double x, double *X, double *F, int N)
{
	double
		h, h2, h4,
		nom0, nom1, nom2,
		dx = X[1] - X[0],
		res;
	int ix = getIndex(x, X, N);

	if (ix == 0 || ix == N - 2)// 3-point scheme
	{
		if (ix == 0) ix += 1;
		h = (x - X[ix]) / dx;
		nom0 = 0.5*h*(h - 1.); nom1 = (1. - h*h); nom2 = 0.5*h*(h + 1.);
		res = nom0*F[ix - 1] + nom1*F[ix] + nom2*F[ix + 1];
	}
	else if (ix>0 && ix<N - 2)
	{
		if (ix == 1) ix = 2;
		h = (x - X[ix]) / dx; h2 = h*h; h4 = h2 - 4; h2 = h2 - 1;
		nom2 = InterpolationWeights[0] * h*h2; nom1 = InterpolationWeights[1] * h*h4; nom0 = InterpolationWeights[2] * h2*h4;
		res = nom2*F[ix - 2] * (h - 2) + nom1*F[ix - 1] * (h - 1) +
			nom0*F[ix] +
			nom1*F[ix + 1] * (h + 1) + nom2*F[ix + 2] * (h + 2);
	}
	else if (ix == -2)// getIndex returns -2, i.e. x>Xmax => extrapolation
	{
		ix = N - 3;
		h = (x - X[ix]) / dx; h2 = h*h; h4 = h2 - 4; h2 = h2 - 1;
		nom2 = InterpolationWeights[0] * h*h2; nom1 = InterpolationWeights[1] * h*h4; nom0 = InterpolationWeights[2] * h2*h4;
		res = nom2*F[ix - 2] * (h - 2) + nom1*F[ix - 1] * (h - 1) +
			nom0*F[ix] +
			nom1*F[ix + 1] * (h + 1) + nom2*F[ix + 2] * (h + 2);
	}
	else if (ix == -1)// getIndex returns -1, i.e. x<Xmin => extrapolation
	{
		ix = 2;
		h = (x - X[ix]) / dx; h2 = h*h; h4 = h2 - 4; h2 = h2 - 1;
		nom2 = InterpolationWeights[0] * h*h2; nom1 = InterpolationWeights[1] * h*h4; nom0 = InterpolationWeights[2] * h2*h4;
		res = nom2*F[ix - 2] * (h - 2) + nom1*F[ix - 1] * (h - 1) +
			nom0*F[ix] +
			nom1*F[ix + 1] * (h + 1) + nom2*F[ix + 2] * (h + 2);
	}
	else res = 0.0;
	return res;
}
//------------------------------------------------------------------------------
// input: matrix A[N][N] and vector B[N]
// solve the SLAU problem A*X = B
// output: desired vector X stored in vector B
//		   if DoInverse == true then A equal A^-1
bool SLAU_GaussJordan(double **a, double *b, int N, bool DoInverse)
{
	int
		i, j, k;
	double
		C,
		**_a = NULL;
	if (DoInverse)
	{
		_a = new double *[N];
		for (i = 0; i<N; i++)
		{
			_a[i] = new double[N];
			for (j = 0; j<N; j++) _a[i][j] = ((i == j) ? 1 : 0);
		}
	}
	//---------------------------------------------------------------------------
	// Privedenie matricy k verhne-treugol'nomu vidu
	for (i = 0; i<N; i++)
	{
		//------------------------------------------------------------------------
		// '1' on the diagonal
		C = 1.0 / a[i][i];
		b[i] *= C;
		for (j = 0; j<N; j++)
		{
			if (j >= i) a[i][j] *= C;
			if (DoInverse) _a[i][j] *= C;
		}
		//------------------------------------------------------------------------
		for (j = i + 1; j<N; j++)// loop over vertical line
		{
			if (fabs(a[j][i])<Constants::zerro) continue;
			C = a[j][i];
			b[j] -= C*b[i];
			for (k = 0; k<N; k++)
			{
				if (k >= i)
				{
					if (k == i) a[j][k] = 0;
					else        a[j][k] -= C*a[i][k];
				}
				if (DoInverse) _a[j][k] -= C*_a[i][k];
			}
		}
		//------------------------------------------------------------------------
	}
	//---------------------------------------------------------------------------
	// obratnyi hod
	for (i = N - 1; i>0; i--)
	{
		//------------------------------------------------------------------------
		// '1' on the diagonal
		C = 1.0 / a[i][i];
		b[i] *= C;
		for (j = 0; j<N; j++)
		{
			if (j >= i) a[i][j] *= C;
			if (DoInverse) _a[i][j] *= C;
		}
		//------------------------------------------------------------------------
		for (j = i - 1; j >= 0; j--)// loop over vertical line
		{
			if (fabs(a[j][i])<Constants::zerro) continue;
			C = a[j][i];
			b[j] -= C*b[i];
			for (k = 0; k<N; k++)
			{
				if (k <= i && k >= j)
				{
					if (k == i) a[j][k] = 0;
					else        a[j][k] -= C*a[i][k];
				}
				if (DoInverse) _a[j][k] -= C*_a[i][k];
			}
		}
	}
	//---------------------------------------------------------------------------
	if (DoInverse)
	{
		for (i = 0; i<N; i++)
		{
			for (j = 0; j<N; j++) a[i][j] = _a[i][j];
			delete[] _a[i];
		}
		delete[] _a;
	}
	//---------------------------------------------------------------------------
	return true;
}